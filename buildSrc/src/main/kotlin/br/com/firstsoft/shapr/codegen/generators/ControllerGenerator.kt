package br.com.firstsoft.shapr.codegen.generators

import br.com.firstsoft.shapr.codegen.GeneratedFile
import br.com.firstsoft.shapr.dsl.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy

/**
 * Generates REST Controller classes using KotlinPoet.
 */
class ControllerGenerator(private val basePackage: String) {
    
    private val entityPackage = "$basePackage.entity"
    private val repositoryPackage = "$basePackage.repository"
    private val controllerPackage = "$basePackage.controller"
    
    // Spring annotations
    private val restControllerAnnotation = ClassName("org.springframework.web.bind.annotation", "RestController")
    private val requestMappingAnnotation = ClassName("org.springframework.web.bind.annotation", "RequestMapping")
    private val getMappingAnnotation = ClassName("org.springframework.web.bind.annotation", "GetMapping")
    private val postMappingAnnotation = ClassName("org.springframework.web.bind.annotation", "PostMapping")
    private val putMappingAnnotation = ClassName("org.springframework.web.bind.annotation", "PutMapping")
    private val deleteMappingAnnotation = ClassName("org.springframework.web.bind.annotation", "DeleteMapping")
    private val pathVariableAnnotation = ClassName("org.springframework.web.bind.annotation", "PathVariable")
    private val requestBodyAnnotation = ClassName("org.springframework.web.bind.annotation", "RequestBody")
    private val responseEntityClass = ClassName("org.springframework.http", "ResponseEntity")
    
    // Shapr runtime classes
    private val authUtilClass = ClassName("br.com.firstsoft.shapr.runtime.auth", "AuthUtil")
    private val accessRuleClass = ClassName("br.com.firstsoft.shapr.dsl", "AccessRule")
    
    fun generate(collection: CollectionDefinition): GeneratedFile {
        val entityClassName = slugToClassName(collection.slug)
        val repositoryName = "${entityClassName}Repository"
        val controllerName = "${entityClassName}Controller"
        
        val entityType = ClassName(entityPackage, entityClassName)
        val repositoryType = ClassName(repositoryPackage, repositoryName)
        
        val classBuilder = TypeSpec.classBuilder(controllerName)
            .addAnnotation(restControllerAnnotation)
            .addAnnotation(
                AnnotationSpec.builder(requestMappingAnnotation)
                    .addMember("%S", "/api/${collection.slug}")
                    .build()
            )
        
        // Constructor with repository injection
        classBuilder.primaryConstructor(
            FunSpec.constructorBuilder()
                .addParameter("repository", repositoryType)
                .build()
        )
        
        // Repository property
        classBuilder.addProperty(
            PropertySpec.builder("repository", repositoryType)
                .initializer("repository")
                .addModifiers(KModifier.PRIVATE)
                .build()
        )
        
        // Add CRUD methods
        classBuilder.addFunction(buildListMethod(entityType, collection.access.read))
        classBuilder.addFunction(buildGetByIdMethod(entityType, collection.access.read))
        classBuilder.addFunction(buildCreateMethod(entityType, collection.access.create))
        classBuilder.addFunction(buildUpdateMethod(entityType, collection.access.update))
        classBuilder.addFunction(buildDeleteMethod(collection.access.delete))
        
        val file = FileSpec.builder(controllerPackage, controllerName)
            .addFileComment("Generated by Shapr CMS - DO NOT EDIT")
            .addType(classBuilder.build())
            .build()
        
        return GeneratedFile(
            packageName = controllerPackage,
            fileName = controllerName,
            content = file.toString()
        )
    }
    
    private fun buildListMethod(entityType: ClassName, accessRule: AccessRule): FunSpec {
        val listType = LIST.parameterizedBy(entityType)
        
        return FunSpec.builder("list")
            .addAnnotation(getMappingAnnotation)
            .returns(listType)
            .addStatement("%T.checkAccess(%L)", authUtilClass, accessRuleToCodeBlock(accessRule))
            .addStatement("return repository.findAll()")
            .build()
    }
    
    private fun buildGetByIdMethod(entityType: ClassName, accessRule: AccessRule): FunSpec {
        val responseType = responseEntityClass.parameterizedBy(entityType)
        
        return FunSpec.builder("getById")
            .addAnnotation(
                AnnotationSpec.builder(getMappingAnnotation)
                    .addMember("%S", "/{id}")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("id", Long::class)
                    .addAnnotation(pathVariableAnnotation)
                    .build()
            )
            .returns(responseType)
            .addStatement("%T.checkAccess(%L)", authUtilClass, accessRuleToCodeBlock(accessRule))
            .addCode("""
                |return repository.findById(id)
                |    .map { %T.ok(it) }
                |    .orElse(%T.notFound().build())
                |""".trimMargin(), responseEntityClass, responseEntityClass)
            .build()
    }
    
    private fun buildCreateMethod(entityType: ClassName, accessRule: AccessRule): FunSpec {
        return FunSpec.builder("create")
            .addAnnotation(postMappingAnnotation)
            .addParameter(
                ParameterSpec.builder("entity", entityType)
                    .addAnnotation(requestBodyAnnotation)
                    .build()
            )
            .returns(entityType)
            .addStatement("%T.checkAccess(%L)", authUtilClass, accessRuleToCodeBlock(accessRule))
            .addStatement("return repository.save(entity)")
            .build()
    }
    
    private fun buildUpdateMethod(entityType: ClassName, accessRule: AccessRule): FunSpec {
        val responseType = responseEntityClass.parameterizedBy(entityType)
        
        return FunSpec.builder("update")
            .addAnnotation(
                AnnotationSpec.builder(putMappingAnnotation)
                    .addMember("%S", "/{id}")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("id", Long::class)
                    .addAnnotation(pathVariableAnnotation)
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("entity", entityType)
                    .addAnnotation(requestBodyAnnotation)
                    .build()
            )
            .returns(responseType)
            .addStatement("%T.checkAccess(%L)", authUtilClass, accessRuleToCodeBlock(accessRule))
            .beginControlFlow("return if (repository.existsById(id))")
            .addStatement("%T.ok(repository.save(entity))", responseEntityClass)
            .nextControlFlow("else")
            .addStatement("%T.notFound().build()", responseEntityClass)
            .endControlFlow()
            .build()
    }
    
    private fun buildDeleteMethod(accessRule: AccessRule): FunSpec {
        val responseType = responseEntityClass.parameterizedBy(UNIT)
        
        return FunSpec.builder("delete")
            .addAnnotation(
                AnnotationSpec.builder(deleteMappingAnnotation)
                    .addMember("%S", "/{id}")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("id", Long::class)
                    .addAnnotation(pathVariableAnnotation)
                    .build()
            )
            .returns(responseType)
            .addStatement("%T.checkAccess(%L)", authUtilClass, accessRuleToCodeBlock(accessRule))
            .beginControlFlow("return if (repository.existsById(id))")
            .addStatement("repository.deleteById(id)")
            .addStatement("%T.noContent().build()", responseEntityClass)
            .nextControlFlow("else")
            .addStatement("%T.notFound().build()", responseEntityClass)
            .endControlFlow()
            .build()
    }
    
    private fun accessRuleToCodeBlock(rule: AccessRule): CodeBlock {
        return when (rule) {
            is AccessRule.Public -> CodeBlock.of("%T.Public", accessRuleClass)
            is AccessRule.Authenticated -> CodeBlock.of("%T.Authenticated", accessRuleClass)
            is AccessRule.Deny -> CodeBlock.of("%T.Deny", accessRuleClass)
            is AccessRule.Roles -> {
                val rolesList = rule.roles.joinToString(", ") { "\"$it\"" }
                CodeBlock.of("%T.Roles(listOf($rolesList))", accessRuleClass)
            }
        }
    }
}
