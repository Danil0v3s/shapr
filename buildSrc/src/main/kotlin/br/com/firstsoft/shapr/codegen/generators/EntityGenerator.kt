package br.com.firstsoft.shapr.codegen.generators

import br.com.firstsoft.shapr.codegen.GeneratedFile
import br.com.firstsoft.shapr.dsl.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy

/**
 * Generates JPA @Entity classes from collection definitions using KotlinPoet.
 */
class EntityGenerator(private val basePackage: String) {
    
    private val entityPackage = "$basePackage.entity"
    
    // JPA annotation classes
    private val entityAnnotation = ClassName("jakarta.persistence", "Entity")
    private val tableAnnotation = ClassName("jakarta.persistence", "Table")
    private val idAnnotation = ClassName("jakarta.persistence", "Id")
    private val generatedValueAnnotation = ClassName("jakarta.persistence", "GeneratedValue")
    private val generationTypeClass = ClassName("jakarta.persistence", "GenerationType")
    private val columnAnnotation = ClassName("jakarta.persistence", "Column")
    private val manyToOneAnnotation = ClassName("jakarta.persistence", "ManyToOne")
    private val manyToManyAnnotation = ClassName("jakarta.persistence", "ManyToMany")
    private val joinColumnAnnotation = ClassName("jakarta.persistence", "JoinColumn")
    private val joinTableAnnotation = ClassName("jakarta.persistence", "JoinTable")
    private val fetchTypeClass = ClassName("jakarta.persistence", "FetchType")
    private val instantClass = ClassName("java.time", "Instant")
    
    fun generate(collection: CollectionDefinition): GeneratedFile {
        val className = slugToClassName(collection.slug)
        
        val classBuilder = TypeSpec.classBuilder(className)
            .addModifiers(KModifier.DATA)
            .addAnnotation(entityAnnotation)
            .addAnnotation(
                AnnotationSpec.builder(tableAnnotation)
                    .addMember("name = %S", collection.slug)
                    .build()
            )
        
        val constructorBuilder = FunSpec.constructorBuilder()
        
        // Add ID property
        addIdProperty(constructorBuilder, classBuilder)
        
        // Add fields from collection definition
        collection.fields.forEach { field ->
            addFieldProperty(field, constructorBuilder, classBuilder)
        }
        
        // Add timestamp fields if enabled
        if (collection.timestamps) {
            addTimestampProperties(constructorBuilder, classBuilder)
        }
        
        classBuilder.primaryConstructor(constructorBuilder.build())
        
        val file = FileSpec.builder(entityPackage, className)
            .addFileComment("Generated by Shapr CMS - DO NOT EDIT")
            .addType(classBuilder.build())
            .build()
        
        return GeneratedFile(
            packageName = entityPackage,
            fileName = className,
            content = file.toString()
        )
    }
    
    private fun addIdProperty(
        constructorBuilder: FunSpec.Builder,
        classBuilder: TypeSpec.Builder
    ) {
        val propSpec = PropertySpec.builder("id", Long::class)
            .initializer("id")
            .addAnnotation(idAnnotation)
            .addAnnotation(
                AnnotationSpec.builder(generatedValueAnnotation)
                    .addMember("strategy = %T.IDENTITY", generationTypeClass)
                    .build()
            )
            .build()
        
        constructorBuilder.addParameter(
            ParameterSpec.builder("id", Long::class)
                .defaultValue("0")
                .build()
        )
        classBuilder.addProperty(propSpec)
    }
    
    private fun addTimestampProperties(
        constructorBuilder: FunSpec.Builder,
        classBuilder: TypeSpec.Builder
    ) {
        // createdAt
        val createdAtType = instantClass.copy(nullable = true)
        constructorBuilder.addParameter(
            ParameterSpec.builder("createdAt", createdAtType)
                .defaultValue("null")
                .build()
        )
        classBuilder.addProperty(
            PropertySpec.builder("createdAt", createdAtType)
                .initializer("createdAt")
                .addAnnotation(
                    AnnotationSpec.builder(columnAnnotation)
                        .addMember("name = %S", "created_at")
                        .build()
                )
                .build()
        )
        
        // updatedAt
        val updatedAtType = instantClass.copy(nullable = true)
        constructorBuilder.addParameter(
            ParameterSpec.builder("updatedAt", updatedAtType)
                .defaultValue("null")
                .build()
        )
        classBuilder.addProperty(
            PropertySpec.builder("updatedAt", updatedAtType)
                .initializer("updatedAt")
                .addAnnotation(
                    AnnotationSpec.builder(columnAnnotation)
                        .addMember("name = %S", "updated_at")
                        .build()
                )
                .build()
        )
    }
    
    private fun addFieldProperty(
        field: FieldDefinition,
        constructorBuilder: FunSpec.Builder,
        classBuilder: TypeSpec.Builder
    ) {
        when (val type = field.type) {
            is FieldType.Text -> addTextProperty(field.name, type, constructorBuilder, classBuilder)
            is FieldType.Textarea -> addTextareaProperty(field.name, type, constructorBuilder, classBuilder)
            is FieldType.Number -> addNumberProperty(field.name, type, constructorBuilder, classBuilder)
            is FieldType.Checkbox -> addCheckboxProperty(field.name, type, constructorBuilder, classBuilder)
            is FieldType.Email -> addEmailProperty(field.name, type, constructorBuilder, classBuilder)
            is FieldType.Date -> addDateProperty(field.name, type, constructorBuilder, classBuilder)
            is FieldType.Relationship -> addRelationshipProperty(field.name, type, constructorBuilder, classBuilder)
        }
    }
    
    private fun addTextProperty(
        name: String,
        type: FieldType.Text,
        constructorBuilder: FunSpec.Builder,
        classBuilder: TypeSpec.Builder
    ) {
        val kotlinType = String::class.asTypeName().copy(nullable = !type.required)
        val defaultValue = if (type.required) "\"\"" else "null"
        
        val columnBuilder = AnnotationSpec.builder(columnAnnotation)
            .addMember("nullable = %L", !type.required)
            .addMember("length = %L", type.maxLength)
        if (type.unique) columnBuilder.addMember("unique = %L", true)
        
        constructorBuilder.addParameter(
            ParameterSpec.builder(name, kotlinType).defaultValue(defaultValue).build()
        )
        classBuilder.addProperty(
            PropertySpec.builder(name, kotlinType)
                .initializer(name)
                .addAnnotation(columnBuilder.build())
                .build()
        )
    }
    
    private fun addTextareaProperty(
        name: String,
        type: FieldType.Textarea,
        constructorBuilder: FunSpec.Builder,
        classBuilder: TypeSpec.Builder
    ) {
        val kotlinType = String::class.asTypeName().copy(nullable = !type.required)
        val defaultValue = if (type.required) "\"\"" else "null"
        
        constructorBuilder.addParameter(
            ParameterSpec.builder(name, kotlinType).defaultValue(defaultValue).build()
        )
        classBuilder.addProperty(
            PropertySpec.builder(name, kotlinType)
                .initializer(name)
                .addAnnotation(
                    AnnotationSpec.builder(columnAnnotation)
                        .addMember("columnDefinition = %S", "TEXT")
                        .addMember("nullable = %L", !type.required)
                        .build()
                )
                .build()
        )
    }
    
    private fun addNumberProperty(
        name: String,
        type: FieldType.Number,
        constructorBuilder: FunSpec.Builder,
        classBuilder: TypeSpec.Builder
    ) {
        val kotlinType = if (type.integerOnly) {
            Long::class.asTypeName().copy(nullable = !type.required)
        } else {
            Double::class.asTypeName().copy(nullable = !type.required)
        }
        val defaultValue = when {
            !type.required -> "null"
            type.integerOnly -> "0L"
            else -> "0.0"
        }
        
        constructorBuilder.addParameter(
            ParameterSpec.builder(name, kotlinType).defaultValue(defaultValue).build()
        )
        classBuilder.addProperty(
            PropertySpec.builder(name, kotlinType)
                .initializer(name)
                .addAnnotation(
                    AnnotationSpec.builder(columnAnnotation)
                        .addMember("nullable = %L", !type.required)
                        .build()
                )
                .build()
        )
    }
    
    private fun addCheckboxProperty(
        name: String,
        type: FieldType.Checkbox,
        constructorBuilder: FunSpec.Builder,
        classBuilder: TypeSpec.Builder
    ) {
        constructorBuilder.addParameter(
            ParameterSpec.builder(name, Boolean::class).defaultValue("%L", type.defaultValue).build()
        )
        classBuilder.addProperty(
            PropertySpec.builder(name, Boolean::class)
                .initializer(name)
                .addAnnotation(
                    AnnotationSpec.builder(columnAnnotation)
                        .addMember("nullable = %L", false)
                        .build()
                )
                .build()
        )
    }
    
    private fun addEmailProperty(
        name: String,
        type: FieldType.Email,
        constructorBuilder: FunSpec.Builder,
        classBuilder: TypeSpec.Builder
    ) {
        val kotlinType = String::class.asTypeName().copy(nullable = !type.required)
        val defaultValue = if (type.required) "\"\"" else "null"
        
        val columnBuilder = AnnotationSpec.builder(columnAnnotation)
            .addMember("nullable = %L", !type.required)
        if (type.unique) columnBuilder.addMember("unique = %L", true)
        
        constructorBuilder.addParameter(
            ParameterSpec.builder(name, kotlinType).defaultValue(defaultValue).build()
        )
        classBuilder.addProperty(
            PropertySpec.builder(name, kotlinType)
                .initializer(name)
                .addAnnotation(columnBuilder.build())
                .build()
        )
    }
    
    private fun addDateProperty(
        name: String,
        type: FieldType.Date,
        constructorBuilder: FunSpec.Builder,
        classBuilder: TypeSpec.Builder
    ) {
        val kotlinType = instantClass.copy(nullable = !type.required)
        
        constructorBuilder.addParameter(
            ParameterSpec.builder(name, kotlinType).defaultValue("null").build()
        )
        classBuilder.addProperty(
            PropertySpec.builder(name, kotlinType)
                .initializer(name)
                .addAnnotation(
                    AnnotationSpec.builder(columnAnnotation)
                        .addMember("nullable = %L", !type.required)
                        .build()
                )
                .build()
        )
    }
    
    private fun addRelationshipProperty(
        name: String,
        type: FieldType.Relationship,
        constructorBuilder: FunSpec.Builder,
        classBuilder: TypeSpec.Builder
    ) {
        val relatedClassName = slugToClassName(type.relationTo)
        val relatedType = ClassName(entityPackage, relatedClassName)
        
        if (type.hasMany) {
            // ManyToMany relationship
            val setType = SET.parameterizedBy(relatedType)
            
            constructorBuilder.addParameter(
                ParameterSpec.builder(name, setType).defaultValue("emptySet()").build()
            )
            classBuilder.addProperty(
                PropertySpec.builder(name, setType)
                    .initializer(name)
                    .addAnnotation(manyToManyAnnotation)
                    .addAnnotation(
                        AnnotationSpec.builder(joinTableAnnotation)
                            .addMember("name = %S", "${name}_${type.relationTo}")
                            .build()
                    )
                    .build()
            )
        } else {
            // ManyToOne relationship
            val nullableType = relatedType.copy(nullable = !type.required)
            
            constructorBuilder.addParameter(
                ParameterSpec.builder(name, nullableType).defaultValue("null").build()
            )
            classBuilder.addProperty(
                PropertySpec.builder(name, nullableType)
                    .initializer(name)
                    .addAnnotation(
                        AnnotationSpec.builder(manyToOneAnnotation)
                            .addMember("fetch = %T.LAZY", fetchTypeClass)
                            .build()
                    )
                    .addAnnotation(
                        AnnotationSpec.builder(joinColumnAnnotation)
                            .addMember("name = %S", "${name}_id")
                            .addMember("nullable = %L", !type.required)
                            .build()
                    )
                    .build()
            )
        }
    }
}
